"""
Build commands for generating Terraform and other outputs.

Generates infrastructure-as-code from the Cloudstrate model.
"""

import click
import sys
from pathlib import Path


@click.group()
def build():
    """Generate Terraform and other outputs."""
    pass


@build.command()
@click.option(
    "--state",
    "-s",
    type=click.Path(exists=True),
    required=True,
    help="Path to mapping state file",
)
@click.option(
    "--output",
    "-o",
    type=click.Path(),
    default="generated",
    help="Output directory for generated files",
)
@click.option(
    "--format",
    "-f",
    type=click.Choice(["terraform", "opentofu"]),
    default="terraform",
    help="Output format (terraform or opentofu)",
)
@click.option(
    "--modules",
    "-m",
    multiple=True,
    default=["aws", "tenants"],
    help="Modules to generate (can be specified multiple times)",
)
@click.pass_context
def generate(
    ctx: click.Context,
    state: str,
    output: str,
    format: str,
    modules: tuple[str, ...],
) -> None:
    """Generate Terraform from Cloudstrate model.

    Creates Terraform files for AWS accounts, networking, and tenant configuration.

    Example:
        cloudstrate build generate --state mapping-state.yaml --output generated/
    """
    click.echo(f"Generating {format} from: {state}")
    click.echo(f"Output directory: {output}")
    click.echo(f"Modules: {', '.join(modules)}")

    try:
        from cloudstrate.builder.terraform import TerraformBuilder

        builder = TerraformBuilder(
            state_file=state,
            output_dir=output,
            format=format,
            modules=list(modules),
        )

        result = builder.generate()

        click.echo(f"\nGeneration complete:")
        click.echo(f"  Files created: {result.get('files_created', 0)}")
        click.echo(f"  Output directory: {output}")

        if result.get("warnings"):
            click.echo("\nWarnings:")
            for warning in result["warnings"]:
                click.echo(f"  - {warning}")

    except ImportError as e:
        click.echo(f"Error: Builder module not available: {e}", err=True)
        sys.exit(1)
    except Exception as e:
        click.echo(f"Error during generation: {e}", err=True)
        if ctx.obj.get("verbose"):
            import traceback
            traceback.print_exc()
        sys.exit(1)


@build.command()
@click.option(
    "--state",
    "-s",
    type=click.Path(exists=True),
    required=True,
    help="Path to mapping state file",
)
@click.option(
    "--format",
    "-f",
    type=click.Choice(["yaml", "json", "cue"]),
    default="yaml",
    help="Output format",
)
def export(state: str, format: str) -> None:
    """Export Cloudstrate model to various formats.

    Exports the model for use with external tools or validation.

    Example:
        cloudstrate build export --state mapping-state.yaml --format cue
    """
    import yaml
    import json

    with open(state) as f:
        data = yaml.safe_load(f)

    if format == "yaml":
        click.echo(yaml.dump(data, default_flow_style=False))
    elif format == "json":
        click.echo(json.dumps(data, indent=2))
    elif format == "cue":
        # Convert to CUE format
        click.echo("// Generated by Cloudstrate")
        click.echo("package cloudstrate\n")
        click.echo(f"model: {json.dumps(data, indent=2)}")


@build.command()
@click.option(
    "--output",
    "-o",
    type=click.Path(),
    required=True,
    help="Output directory for generated files",
)
@click.option(
    "--init/--no-init",
    default=True,
    help="Run terraform init after generation",
)
@click.option(
    "--validate/--no-validate",
    default=True,
    help="Run terraform validate after generation",
)
@click.pass_context
def validate(ctx: click.Context, output: str, init: bool, validate: bool) -> None:
    """Validate generated Terraform files.

    Runs terraform init and validate on generated configuration.

    Example:
        cloudstrate build validate --output generated/
    """
    import subprocess

    output_path = Path(output)

    if not output_path.exists():
        click.echo(f"Error: Output directory does not exist: {output}", err=True)
        sys.exit(1)

    # Find terraform directories
    tf_dirs = []
    for tf_file in output_path.rglob("*.tf"):
        tf_dir = tf_file.parent
        if tf_dir not in tf_dirs:
            tf_dirs.append(tf_dir)

    if not tf_dirs:
        click.echo("No Terraform files found in output directory")
        return

    click.echo(f"Found {len(tf_dirs)} Terraform directories")

    for tf_dir in tf_dirs:
        click.echo(f"\nValidating: {tf_dir}")

        if init:
            click.echo("  Running terraform init...")
            result = subprocess.run(
                ["terraform", "init", "-backend=false"],
                cwd=tf_dir,
                capture_output=True,
                text=True,
            )
            if result.returncode != 0:
                click.echo(f"  Init failed: {result.stderr}", err=True)
                continue

        if validate:
            click.echo("  Running terraform validate...")
            result = subprocess.run(
                ["terraform", "validate"],
                cwd=tf_dir,
                capture_output=True,
                text=True,
            )
            if result.returncode != 0:
                click.echo(f"  Validation failed: {result.stderr}", err=True)
            else:
                click.echo("  Validation passed")
