"""
Terraform builder wrapper for Cloudstrate CLI.

Wraps the existing generate_terraform.py for use with the CLI.
"""

import sys
from pathlib import Path
from typing import Any, Optional

import yaml


class TerraformBuilder:
    """Wrapper for Terraform generation.

    Creates Terraform files for AWS accounts, networking, and tenant configuration.
    """

    def __init__(
        self,
        state_file: str | Path,
        output_dir: str | Path = "generated",
        format: str = "terraform",
        modules: Optional[list[str]] = None,
    ):
        """Initialize Terraform builder.

        Args:
            state_file: Path to mapping state YAML file
            output_dir: Output directory for generated files
            format: Output format (terraform or opentofu)
            modules: Modules to generate (default: aws, tenants)
        """
        self.state_file = Path(state_file)
        self.output_dir = Path(output_dir)
        self.format = format
        self.modules = modules or ["aws", "tenants"]

        if not self.state_file.exists():
            raise FileNotFoundError(f"State file not found: {state_file}")

        # Load state
        with open(self.state_file) as f:
            self.state = yaml.safe_load(f)

    def generate(self) -> dict[str, Any]:
        """Generate Terraform files.

        Returns:
            Dictionary with:
            - files_created: Number of files created
            - output_dir: Output directory path
            - warnings: List of warnings
        """
        # Try to import existing generator
        foundation_path = Path(__file__).parent.parent.parent / "foundation"
        sys.path.insert(0, str(foundation_path))

        try:
            from generate_terraform import TerraformGenerator

            generator = TerraformGenerator(
                state=self.state,
                output_dir=str(self.output_dir),
                modules=self.modules,
            )

            return generator.generate()

        except (ImportError, TypeError):
            # Fallback to basic generation if module not found or API mismatch
            return self._generate_basic()

    def _generate_basic(self) -> dict[str, Any]:
        """Basic Terraform generation implementation.

        Fallback if the existing generator is not available.
        """
        self.output_dir.mkdir(parents=True, exist_ok=True)

        files_created = 0
        warnings = []

        # Generate main.tf
        main_tf = self._generate_main_tf()
        main_path = self.output_dir / "main.tf"
        main_path.write_text(main_tf)
        files_created += 1

        # Generate variables.tf
        variables_tf = self._generate_variables_tf()
        variables_path = self.output_dir / "variables.tf"
        variables_path.write_text(variables_tf)
        files_created += 1

        # Generate outputs.tf
        outputs_tf = self._generate_outputs_tf()
        outputs_path = self.output_dir / "outputs.tf"
        outputs_path.write_text(outputs_tf)
        files_created += 1

        # Generate terraform.tfvars
        tfvars = self._generate_tfvars()
        tfvars_path = self.output_dir / "terraform.tfvars"
        tfvars_path.write_text(tfvars)
        files_created += 1

        return {
            "files_created": files_created,
            "output_dir": str(self.output_dir),
            "warnings": warnings,
        }

    def _generate_main_tf(self) -> str:
        """Generate main.tf content."""
        lines = [
            "# Generated by Cloudstrate",
            "# Terraform configuration for infrastructure management",
            "",
            "terraform {",
            '  required_version = ">= 1.0"',
            "",
            "  required_providers {",
            "    aws = {",
            '      source  = "hashicorp/aws"',
            '      version = "~> 5.0"',
            "    }",
            "  }",
            "}",
            "",
            "provider \"aws\" {",
            "  region = var.aws_region",
            "}",
            "",
        ]

        # Add account data sources
        for subtenant in self.state.get("subtenants", []):
            for account_id in subtenant.get("aws_accounts", []):
                lines.extend([
                    f"# Account: {subtenant.get('name', account_id)}",
                    f"# AWS Account ID: {account_id}",
                    "",
                ])

        return "\n".join(lines)

    def _generate_variables_tf(self) -> str:
        """Generate variables.tf content."""
        return '''# Generated by Cloudstrate

variable "aws_region" {
  description = "AWS region for resources"
  type        = string
  default     = "us-east-1"
}

variable "environment" {
  description = "Environment name"
  type        = string
  default     = "production"
}

variable "tags" {
  description = "Common tags for all resources"
  type        = map(string)
  default     = {}
}
'''

    def _generate_outputs_tf(self) -> str:
        """Generate outputs.tf content."""
        return '''# Generated by Cloudstrate

output "cloudstrate_version" {
  description = "Cloudstrate version used for generation"
  value       = "0.1.0"
}
'''

    def _generate_tfvars(self) -> str:
        """Generate terraform.tfvars content."""
        lines = [
            "# Generated by Cloudstrate",
            "# Customize these values for your environment",
            "",
            'aws_region  = "us-east-1"',
            'environment = "production"',
            "",
            "tags = {",
            '  ManagedBy = "Cloudstrate"',
            "}",
        ]

        return "\n".join(lines)
